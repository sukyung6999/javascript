12장_함수

1. 함수란
- 매개변수(parameter), 인수(argument), 반환값(return value)을 필요로 함

- 함수는 함수 정의를 통해 생성

- 함수 이름은 함수 몸체 내부에서만 사용할 수 있음, 함수를 호출하려면 함수를 할당한 식별자로 호출해야함

- 매개변수와 인수의 개수가 일치하는지 확인하지 않음

- 매개변수의 타입을 사전에 지정할 수 없음

  예 :
  function sample (x, y) { // 식별자, 매개변수
    return x + y; // 반환값
  }
  sample(2,5);// 인수

------------------------------------------------------------

2. 함수를 사용하는 이유는 코드의 재사용이 가능하기 때문에 유지 보수의 편의성을 높이고, 
코드의 신뢰성을 높임

1) 여러번 호출 가능
2) 실행 시점을 개발자가 정할 수 있음

------------------------------------------------------------

3. 함수 리터럴

함수는 객체 타입의 값임!!!!!!!!!
객체와 다른 점은, 함수만 "호출을 할 수 있다는 것" 그리고 "함수만의 고유 프로퍼티가 있음"

(리터럴은 값을 생성하기 위한 표기법)

------------------------------------------------------------

4. 함수 정의

1) 함수 선언문

function add (x, y) {
  return x + y;
}
  => 함수 리터럴과 동일하나, 함수선언문은 식별자 이름을 생략할 수 없다

  [함수 선언문 vs 함수 리터럴]
  - 함수 선언문은 표현식이 아닌 문 / 함수 리터럴은 표현식인 문
  - 차이점 : 문맥으로 해석
    자바스크립트 엔진은 변수에 할당하거나 피연산자로 쓰이는 경우엔 함수 리터럴로 평가하고, 그 외에는 함수 선언문으로 해석한다
    예 : ()는 그룹 연산자이고, 그룹 연산자의 피연산자는 값으로 평가되어야 함. 그래서 그룹 연산자 안에 있는 것은 객체 리터럴로 해석함
  - 호출의 차이
    함수는 함수 이름으로 호출하는 것이 아닌, 함수 객체가 할당된 식별자로 호출하는 것이다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 전혀 몰랐던 내용!!!!!!!!!!!!!!!꼭 기억하자
    함수 선언문 : 외부에서 참조 가능, 자바스크립트 엔진은 함수 이름과 동일한 이름으로 식별자를 암묵적으로 생성 후 함수 객체를 할당함
    함수 리터럴 : 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자. 즉, 외부에서 참조할 수 없는 식별자임 

==============================================================

2) 함수 표현 식 
var add = function (x, y) {
  return x + y;
}

  함수는 객체임
  +
  함수는 배열의 요소으로도, 프로퍼티의 값으로도, 변수에 할당될 수 있음
  =
  함수는 일급 객체(값의 성질을 갖는 객체) 임

  예: 
  var add = function foo (x,y) {
    return x + y;
  }
  add(2,3);

[함수 생성 시점과 함수 호이스팅]

  * 함수 선언문으로 생성한 함수 : 런타임 이전
    => 호출이 선언문 전에 있지만, 선언문이 선두로 끌어올려진 것처럼 동작하는 것을 "호이스팅"이라 함

  * 함수 리터럴로 생성한 함수 : 런타임때

[변수 호이스팅 vs 함수 호이스팅]
  var 키워드는 undefined로 초기화하고
  함수 선언문은 암묵적으로 함수 이름으로 식별자를 생성 후 함수 객체로 초기화함

  => 따라서 함수 표현식은 변수에 할당한것이기 때문에
  런타임 이전에 undefined로 초기화가 돼서 호이스팅이 안됨

∴ 함수 선언문은 함수가 선언이 되어야 참조,호출할 수 있는 당연한 규칙을 무시하는 호이스팅으로 인해서, 
함수 선언문 대신 함수 표현식을 사용할 것을 권장

==============================================================

3) Function 생성자 함수 
(* 생성자 함수란? 객체를 생성하는 함수)
var add = new Function ('x', 'y', 'return x + y');

Function 생성자 함수를 사용하는 것은 바람직하지 않음
왜죠? 
=> 클로저를 생성하지 않는다????????
=> 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작


==============================================================

4) 화살표 함수 
var add = (x,y) => {
  return x + y;
}

- 항상 익명 함수로 정의

26장에서 자세히...

------------------------------------------------------------

5. 함수 호출
호출방법 : 식별자()

- 매개변수 : 함수 몸체 내부에서 변수와 동일하게 취급
매개변수보다 인수가 많을 경우, 초과한 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다
(* arguments 객체 : 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할때 유용)

  5-1. 매개변수와 인수

  5-2. 인수 확인

  5-3. 매개변수의 최대 개수
  
    Q. 최대 개수에 대한 제한은 없으나,
    최대 몇 개를 사용해야 효율적일까?

    매개변수는 순서를 고려해야 하므로 
    인수의 순서를 신경써야하므로 실수 발생 가능성이 높음

    ∴ 즉, 매개변수의 순서나 개수가 변경되면 인수도 바꿔줘야하므로,
    유지보수가 나쁨

    A. 최대 3개 이상을 넘기지 않는 것을 권장, 
    그 이상이 필요할 경우 하나의 매개변수를 선언하고 "객체"를 인수로 전달하는 것이 좋음
    => 프로퍼티 키만 정확히 지정하면 매개변수 순서를 신경쓰지 않아도 됨

    5-4. 반환문
    return (표현식)

    1. 반환문은 2가지 역할을 함
      a) 반환문은 실행을 중단하고 함수 몸체를 빠져나옴
      b) 표현식을 평가해서 반환 (단, 표현식이 명시적이지 않을 경우 undefined를 반환함 )

    2. 반환문은 생략가능, 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 Undefined를 반환함 

    3. 반환문에서 사용할 표현식에서 줄바꿈이 있으면 
    "세미콜론 자동 삽입 기능"에 의해 세미콜린 추가되어 세미콜론 뒤에 표현식이 무시됨.

    4. 반환문은 함수 몸체 내부에서만 사용 가능
      (단, 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다)

------------------------------------------------------------

6. 참조에 의한 전달과 외부 상태의 변경

