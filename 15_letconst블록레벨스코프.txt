15장_let,const키워드와 블록레벨 스코프는

  15-1. var 키워드로 선언한 변수의 문제점
  
    1) 중복 선언 가능
    : 초기화문인 경우엔 var 키워드가 없는 것처럼 작동하고,
    초기화문이 아닌 선언문은 무시됨

      예시: 
      var x = 1;
      var y = 100;

      var x = 2;
      var y;

      console.log(x) // 2 -> 초기화문이 있는 경우임
      console.log(y) // 100 -> 초기화문이 없는 경우임

    2) 함수 레벨 스코프
    var 키워드로 선언한 변수중
    함수 내에서 선언한 변수만 지역 변수로 인정함     

    3) 변수 호이스팅
    선언문이 위로 끌어올려진 것처럼 동작해서 
    선언문 이전에 참조가 가능함

    => 오류를 발생하지 않지만, 
    가독성을 떨어뜨리고 오류를 발생시킬 여지가 있음

------------------------------------------------------------

  15-2. let 키워드
    
    1) 중복 선언 금지

    2) 블록 레벨 스코프
    : 모든 블록을 지역 스코프로 인정

    3) 변수 호이스팅이 되지만 안된것처럼 동작함
  
    - var 키워드는 런타임 이전에 암묵적으로 선언이 되자마자 undefined로 초기화됨
    vs
    - let 키워드는 런타임 인전에 암묵적으로 선언되고, 선언문에 가서야 undefined로 초기화됨


    let foo = 1;

    {
      console.log(foo); // ReferenceError : cannot access foo 'foo' before Initialization
      let foo = 100;
    }

    4) 전역 객체와 let
    let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아님

------------------------------------------------------------

  15-3. const 키워드
  : 상수 선언

  1) 선언과 초기화가 반드시 한번에!

  2) 재할당 금지
  : 재할당을 금지할 뿐 불변을 의미하지 않는다(객체를 할당한 경우 변경이 가능하므로)

  3) 일반적으로 상수 이름을 대문자, 스네이크(_) 케이스로 사용

  4) const 키워드와 객체
  const 키워드로 원시값을 할당한 경우, 재할당없이 변경이 불가능한데 (const는 재할당이 안돼서 상수처럼 사용하지만),
  객체를 할당한 경우 const로 선언한 변수는 변경이 가능하다. (객체는 재할당없이 직접 변경 가능하기 때문)

