
19장_프로토타입

  자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어다
  자바스크립트를 이루고 있는 대부분이 객체임

------------------------------------------------------------

  19-1. 객체지향 프로그래밍

  여러개의 독립적인 단위(객체)의 집합 (<-> 명령형 프로그래밍 : 함수 또는 명령어의 목록, 절차지향적 )

  - 속성

  - 추상화 : 다양한 속성중에 프로그래밍에 필요한 속성만 간추려 표현한 것

  - 객체 : 속성을 통해 다양한 값들을 하나의 단위로 구성한 복잡한 자료구조
          ㄴ 상태(프로퍼티)와 동작(메서드)을 묶어 하나의 논리적인 단위

  예시 시작 >>>>

  const circle = {
    radius: 5,
    getDiameter () {
      return this.radius * 2;
    },
    getPiameter () {
      return this.radius * Math.PI * 2;
    },
    getArea () {
      return this.radius * Math.PI ** 2;
    }
  }

  <<<<< 예시 끝

------------------------------------------------------------

19-2. 상속과 프로토타입

- 상속 : 다른 객체의 프로퍼티와 메서드를 상속받아 사용가능
      ㄴ 프로토타입을 기반으로 상속
      ㄴ 코드의 재사용성이 가능

      예시 시작 >>>>>

      function Circle (radius) {
        this.radius: radius,
        this.getArea: function () {
          return radius * Math.PI ** 2;
        }
      }

      const circle1 = new Circle(5); 
      const circle2 = new Circle(10); 
      console.log(circle1.getArea === circle2.getArea); // false

      <<<<< 예시 끝

      첫 번째 예시처럼 생성자 함수 하나로 여러개의 인스턴스를 생성할 수가 있음
      그러나 완벽하지는 않음

      1. radius는 여러값들이 들어가기도 하고, 동일한 값들이 들어감 (? 이 말이 무얼 의미하는 걸까, 음 값을 넣는 것이기 때문에 값에 따라 달라지기도 하는 것을 의미하는 걸까?)
      2. getArea 매세드는 모든 인스턴스에서 동일한 getArea 메서드를 생성하기 때문에 메모리를 불필요하게 낭비한다


그래서,
생성자 함수가 생성한 인스턴스는 자신의 프로토타입은 상위(부모) 객체의 프로토타입의 모든 프로퍼티를 상속받음

      예시 시작 >>>>>>

      function Circle (radius) {
        this.radius: radius
      };

      Circle.prototype.getArea = function (radius) { // 프로토타입은 Circle 생성자 함수의 프로토타입 프로퍼티에 바인딩되어 있음
        return radius * Math.PI ** 2;
      };

      const circle1 = new Circle(1);
      const circle2 = new Circle(2);
      console.log(circle1.getArea === circle2.getArea); // true

      <<<<<< 예시 끝

      두번째 예시는,
      상태를 나타내는 프로퍼티만 소유하고, 메서드는 부모로부터 상속받음

------------------------------------------------------------

  19-3. 프로토타입 객체

  - 프로토타입 객체(생략해서 프로토타입이라고도 함)는 객체간 상속을 구현하기 위해 사용

  - 프로토타입: 어떤 객체의 상위 객체 역할을 하는 "객체"로서,
             다른 객체에 공유 프로퍼티를 제공

  > 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가짐
    내부 슬롯은 프로토타입의 참조다.

  > [[Prototype]]에 저장되는 프로토타입은 객체가 생성되는 방식에 의해 결정
  예를들어,
  "객체 리터럴"에 의해 생성된 객체의 프로토타입은 Object.prototype
  "생성자 함수"에 의해 생성된 객체의 프로토타입은 생성자 함수의 프로토타입의 프로퍼티에 바인딩

  > 모든 객체는 하나의 prototype을 가짐
  > 모든 prototype은 생성자 함수와 연결되어 있음
  > 자신의 내부 슬롯 [[prototype]]에 직접 접근할 수 없지만, __proto__ 접근자 프로퍼티를 이용해서 간접적으로 접근하고
    내부 슬롯 [[prototype]]이 가리키는 prototype에 접근할 수 있음

  ======================================================

  [1] __proto__ 는 접근자 프로퍼티 
    접근자 프로퍼티 속성에는 [Get], [Set] 접근자 함수들이 있고,
    [Get]에는 getter 함수, [Set]에는 Setter 함수가 있어서
    프로토타입을 읽거나 저장할 수 있음

    예시 시작 >>>>

    const obj = {};
    const person = {name: 'one'};

    console.log(obj.__proto__);

    obj.__proto__ = person;

    console.log(obj.__proto__); // {name: 'one'}
    
  
  [2] __proto__ 접근자 프로퍼티는 상속을 통해 사용
      ㄴ __proto__ 접근자 프로퍼티는 객체가 소유하는 게 아니라, Object.prototype의 프로퍼티임!!!!!!!!!!!!!!!!!!!!!!!
      ㄴ 예시 시작 >>>>
        const person = {name: 'one'};

        console.log(person.hasOwnProperty('__proto__')); // false 즉, person 객체는 __proto__ 접근자 프로퍼티를 소유하지 않음

        console.log(object.getOwnPropertyDescriptor(Object.prototype, '__proto__')) // 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티임

        console.log({}.prototype === Object.prototype); // true 즉, 모든 객체는 Object.prototype의 프로퍼티를 상속받아 사용할 수 있음

  [3] __proto__ 접근자 프로퍼티를 이용해서 prototype에 접근하는 이유?
      ㄴ 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서

      예시 시작 >>>>
      const parent = {};
      const child = {};

      parent.__proto__ = child;
      child.__proto__ = parent;

      