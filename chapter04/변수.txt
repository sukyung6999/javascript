4장_변수

    [변수가 필요한 이유]

        1. 코드가 실행될때마다 값이 저장될 메모리 주소는 변경됨
            → 그러면 값이 이미 저장된 메모리 주소도 변경되는걸까?
        2. 또한 코드가 실행되어야 값이 저장된 메모리 주소를 알 수 있음

        따라서 메모리 주소를 통해 값에 직접 접근하는것은 옳지 않으므로,
        값이 저장된 메모리 공간을 가리키는 상징적인 이름인 “변수”를 사용함

        프로그래밍 언어의 컴파일러나 인터프리터에 의해 
        “변수”를 “값이 저장된 메모리 주소”로 치환되어 실행

        - 할당: 변수에 값을 저장
        - 참조: 변수에 저장된 값을 불러옴

    [식별자]

    메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자

    변수, 함수, 클래스 등은 모두 식별자임
    함수도 자바스크립트에서는 값임


    [선언]

    공간 확보, 선언과 동시에 초기값은 undefined

    - 선언과 초기화 
    자바스크립트 엔진은 2단계를 걸쳐 수행
    [선언 단계]: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
    [초기화 단계]: 암묵적으로 undefined 값을 할당하여 초기화시켜줌

    - 실행 컨텍스트
    Q: 변수명과 같은 식별자는 어디에 저장되는가?
    A: 실행 컨텍스트에 저장됨
    → 나중에 뒷 챕터에서 더 자세히…

    - 호이스팅
    자바스크립트 엔진은 아래 두 단계를 걸쳐 실행
    [준비 단계]: 소스코드의 평가 (모든 선언문, 즉 변수 선언, 함수 선언 등…)
    [실행 단계]: 소스코드를 한 줄씩 실행
    
    - 할당
    자바스크립트 엔진은 선언과 할당을 동시에 하든 따로 하든
    ”선언”(런타임 이전에 실행)과 “할당”(런타임에 실행)을 각각 실행함

    - 상수 vs 변수
    [상수] 재할당되지 않는 고정된 값 
    [변수] 재할당하여 값을 변경할 수 있는 값

    -재할당
    : 재할당한 값은 새로운 메모리 공간에 저장되며,
    이전에 확보해둔 메모리 공간에는 어떤 식별자와도 연결되어 있지 않고
    가비지 컬렉터에 의해 메모리에서 자동 해제됨(해제 시점은 언제인지 예측할 수 없다)

    * 가비지 콜렉터
    * 언매니지드 언어 vs 매니지드 언어
    [언매니지드 언어] : 메모리 제어를 개발자가 제어할 수 있음 ex) c언어
    [매니지드 언어] : 메모리를 할당하고 해제(해제는 가비지 콜렉터가 함)할 수 없음 ex) 자바스크립트
