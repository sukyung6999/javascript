11장_원시 값과 객체 비교

데이터 타입을 원시타입과 객체타입으로 구분하는 이유는?
=> 두 개가 근본적으로 다르기 때문
그렇다면, 어떤 점에서 근본적으로 차이가 있을까?
=> 크게 3가지로 나뉨

1
원시 타입 : 변경 불가능한 값
객체 타입 : 변경 가능한 값

2 
변수에 원시 값을 할당하면 확보된 메모리 공간에 "실제 값"이 저장됨
변수에 객체를 할당하면 메모리 공간에 "참조 값"이 저장됨 

3 
값에 의한 전달 : 원시 값을 갖는 변수를 다른 변수에 할당하면 원시값이 복사되어 전달
참조에 의한 전달 : 객체를 가리키는 변수를 다른 변수에 할당하면 참조값이 복사되어 전달

------------------------------------------------------------

11-1. 원시 값

변경 불가능한 값
=> 변경 불가능하다는게 무슨 말일까?

=> 변수는 확보된 메모리 공간을 말하며, 공간에 대한 식별자를 말함
값은 데이터로서 표현식을 평가한 결과임

=> 따라서 변경 불가능하다는 것은 값이 변경안된다는? 말...?

=> 다시 말하면, 원시값 자체를 변경하는게 불가능, 변수값이 변경 불가능이라는 말이 아님

=> 단, 상수와 원시값을 동일시해서는 안됨
상수는 재할당이 안되는 변수일 뿐 원시값이 아님

이러한 원시값의 특성이 데이터의 신뢰성을 보장함

변수에 새로운 값을 재할당할때, 기존 값이 담긴 메모리 공간에 새로운 값이 저장되는게 아니라
새로운 값은 새로운 메모리 공간에 저장이 되고 참조가 바뀐다
즉, 이런 원리로 작동하는 이유는 원시값이 변경 불가능하기 때문
=> 값의 이러한 특성을 불변성이라고 한다

------------------------------------------------------------

11-2. 문자열과 불변성 : 결론 = 문자열은 유사 배열 객체이나 원시값임!

원시값의 타입에 따라 메모리 공간의 크기도 정해지는데,
문자열(2바이트)과 숫자(8바이트) 외의 원시값은 크기가 정해져 있진 않다.

- 문자열 : 문자(2바이트)가 몇개 있느냐에 따라 크기가 정해짐
C언어나 자바에서는 문자열이라는 원시값이 존재하지 않음.
자바스크립트는 문자열이라는 원시값이 존재하고,
문자열은 몇개의 문자가 모였으냐에 따라 문자열의 크기가 정해짐 (하나의 문자는 2바이트)

↕️

- 숫자 : 1이던 1000이던 8바이트 크기가 고정임

문자열은 객체가 아닌 유사 배열 객체! 
그런데!! 문자열은 원시값인데 왜 객체라고 하냐면,
원시값을 객체처럼 사용하면 원시값을 감싸는 레퍼 객체로 자동 변환되기 때문
문자열은 원시값임! 
그렇기 때문에 인덱스로 프로퍼티 값에 접근해서 원시값을 바꾸려 해도 바뀌지 않음

* 유사 배열 객체는 
- 인덱스로 프로퍼티 값에 접근 가능
- length 프로포터를 갖음.

------------------------------------------------------------

11-3. 값에 의한 전달

var score = 80;
var copy = score;

copy에는 score의 값을 복사해서 새로 생성된 원시값이 저장됨

예)
console.log(score === copy); // true 
=> 값은 같지만, 저장된 메모리 공간은 다르다

=> 그런데 실제로 자바스크립트 엔진이 이와 같이 동작하지 않을 수 있음

======

반대의 경우로, 
copy에 score 원시값이 그대로 전달이 될수도 있음(score의 원시값이 담긴 메모리 공간을 참조할 수도 있다는 말)

------------------------------------------------------------

11-4. 객체

객체는 프로퍼티 개수는 정해져 있지 않음, 사전에 메모리 공간을 확보할 수 가 없음

객체는 복합적인 자료구조, 원시값에 비해 브라우저별로 구현 방식이 다를 수 있음

  1) 변경 가능한 값
  원시값을 할당한 변수는 해당 값의 메모리 주소를 기억해서 원시값에 접근. 따라서, 변수는 원시값 자체를 값으로 갖음?
  하지만, 객체를 할당한 변수는 객체가 저장된 메모리 공간에 접근하면 참조값에 접근할 수 있음? 참조값은 객체가 저장된 메모리 공간의 주소임.

  일반적으로,
  원시값을 갖는 변수는 "변수는 윈시값이다"라고 표현
  반대로, 객체를 갖는 변수는 "변수를 객체를 참조한다(가리킨다)"라고 표현

  원시값을 갖는 변수를 변경하려면 재할당밖에 없음
  객체를 갖는 변수를 변경하려면 재할당 없이 프로퍼티를 생성, 삭제, 추가하면 됨

  객체가 변경 가능한 값인 이유는 
  객체의 크기가 일정하지 않고 크기가 매우 클수도 있어서 그때마다 새로운 값으로 만들어낸다면 메모리 성능이 나빠진다.
  대신 단점은 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것.

  * 얕은 복사, 깊은 복사
  const o = {x : {y : 1}};

  - 얕은 복사 : 한 단계까지 복사
  const c1 = {...i};
  console.log(c1 === o); // false
  console.log(c1.x === o.x); // true

  -  깊은 복사 : 중첩되어 있는 객체까지 복사
  // npm install lodash 로 lodash 설치 후 node.js에서 실행
  const _ = require('lodash');
  const c2 = _cloneDeep(o); 
  console.log(c2 === o) // false
  console.log(c2.x === o.x) // false


  2) 참조에 의한 전달
  객체를 할당한 변수를 할당할 경우, 하나의 객체를 참조함.

  결론
  "값에 의한 전달"과 "참조에 의한 전달"은 둘다 변수가 기억하는 메모리 공간의 주소에 담긴 값을 복사하는데
  자바스크립트는 메모리 공간의 주소에 원시"값"이 있느냐 참조"값"이 있느냐의 차이일뿐이기 때문에
  사실상 "값에 의한 전달"만 있음
