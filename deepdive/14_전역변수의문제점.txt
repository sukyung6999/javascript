14장_전역 변수의 문제점

  14-1. 변수의 생명 주기
  변수 선언은 런타임 이전에 실행된다 했지만,
  이는 전역 변수에 해당되는 얘기임

  함수 몸체 내에서 선언된 지역 변수는
  함수가 호출이 되어야 "생성"이 되고,
  함수를 다 읽고 나면 "소멸"된다.

  지역 변수의 생명 주기 = 함수의 생명 주기

  전역 코드 vs 함수
  - 전역 코드 : 명시적인 호출 없이 코드가 실행되면 시작되고
              마지막 실행문까지 읽으면 끝남

  - 함수 : 명시적인 호출에 의해 실행 및 시작되며,
          함수의 마지막 실행문이나 반환문에서 끝남

  전역 객체 : 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 객체
    - CSR(브라우저)에서는 window 객체가 전역 객체
    - SSR(Node.js)에서는 global 객체가 전역 객체

    ES11에서는 globalThis가 전역 객체로 통일됨

  전역 객체의 프로퍼티 : 빌트인 객체, 환경에 따른 호스트 객체, var 키워드로 선언한 전역 변수, var 키워드로 선언한 전역 함수

  * var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이므로,
  그 전역 변수의 생명 주기는 전역 객체의 생명 주기와 동일하다

------------------------------------------------------------

  14-2. 전역 변수의 문제점

  1) 암묵적 결합 : 모든 코드가 전역 변수를 참조하고 변경 가능한 것

  2) 긴 생명 주기 : 상태가 변화되기도, 재할당이 될 위험이 큼

  3) 스코프 체인에서 제일 마지막에 존재함

  4) 네임스페이스 오염 : 자바스크립트는 파일을 분리해도 같은 전역 스코프를 공유

------------------------------------------------------------

  14-3. 전역 변수 사용 억제 방법

  변수의 스코프는 좁을수록 좋다!

  1) 즉시 실행 함수 : 모든 코드를 즉시 실행 함수로 감싸면, 즉시 실행 함수의 지역변수가 되니까

  2) 네임스페이스 객체 : 네임스페이스 역할하는 객체를 만들고, 전역 변수로 만들고 싶은것을 네임스페이스 객체의 프로퍼티로 넣기
                    => 어쨌든 네임스페이스 객체도 전역 변수라는 한계를 가짐

  3) 모듈 패턴 : 관련이 있는 변수와 함수를 즉시 실행 함수로 감싸 하나의 모듈을 만듬

    - 전역 변수를 억제
    - 캡슐화 : 상태를 나타내는 "프로퍼티"와 참조하고 조작할 수 있는 동작 "매서드"를 하나로 묶은 것

    var counter = ( function () {
      var num = 0;

      return (
        increase () {
          return ++num;
        },
        decrease () {
          return --num;
        }

      )
    }());

    console.log(counter.increase()); // 1
    console.log(counter.increase()); // 2
    console.log(counter.decrease()); // 1
    console.log(counter.decrease()); // 0


    즉시 실행 함수는 객체를 반환
    => 이 객체에 외부에 노출하고 싶은 변수나 함수를 객체에 넣어서 반환 : 퍼블릭 멤버
    => 반환하고 싶지 않은 변수나 함수는 객체 담아서 반환하지 않음 : 프라이빗 멤버

------------------------------------------------------------

  14-4. ES6 모듈
        : 파일 자체의 독자적인 모듈 스코프를 제공
        <script type="module" src="sample.mjs"></script> // 파일 확장자는 mjs 를 권장함

        * 구형 브라우저나 IE에서는 제공하지 않음